@カラオケテキスト
--track0:サイズ,1,512,34,1
--track1:ルビサイズ,1,512,16,1
--track2:縁サイズ,0,100,10,1
--track3:進行度,0,100,0
--check0:デバッグ,0
--dialog:テキスト,line="これはテスト｜文章《ぶんしょう》です。";フォント,font="MS UI Gothic";縁色1/col,edgeColor1="0xffffff";縁色2/col,edgeColor2="0x000000";縁ぼかし,edgeBokeh=10;グラデ幅,gradWidth=100;グラデ色 左1/col,gradColor11="0x117ad7";グラデ色 左2/col,gradColor12="0x0f2d47";グラデ色 右1/col,gradColor21="0xffffff";グラデ色 右2/col,gradColor22="0xffffff";左右寄せ[0-2],align=1;ルビ調整,offset={0,0};

local size, rubySize, rubyPos = obj.track0, obj.track1, offset

local r = math.rad(obj.getvalue("rz"))
if rubySize>size then
	rubySize = size
end
if rubyPos==nil or #rubyPos<2 then
	rubyPos={0,0}
end

--テキスト抽出
local lnflag = false
if line:find("\n")~=nil then
	line = line:gsub("\n", "")
	lnflag=true
end

local text, ruby = line, {}
if text:find("(｜.-《.-》)")~=nil then
	repeat
		s1, s2 = text:find("(｜.-《.-》)")
		temp = text:sub(s1,s2)

		local a1, a2 = temp:find("(｜.)")
		local b1, b2 = temp:find("(《.)")

		t = temp:sub(a2,temp:find("《")-1)
		r = temp:sub(b2,temp:find("》")-1)

		text = text:gsub(temp, t, 1)
		table.insert(ruby, {t, r, s1, s1 + t:len() - 1})

	until text:find("(｜.-《.-》)")==nil
end

--情報表示
if obj.check0 then
	obj.setfont(font, obj.track0, 0, "0xffffff")
	local msg = ""

	--DATA
	msg = msg.."[TEXT]"..text.."\n"
	if #ruby>0 then
		for i=1, #ruby do
			msg = msg.."[RUBY]"..ruby[i][1].."("..ruby[i][2]..") "..tostring(ruby[i][3]).."-"..tostring(ruby[i][4]).."\n"
		end
	end

	--INFO
	msg = msg.."[INFO]RUBY OFFSET ("..tostring(rubyPos[1])..","..tostring(rubyPos[2])..")\n"
	if align==0 then
		msg = msg.."[INFO]ALIGN LEFT\n"
	elseif align==2 then
		msg = msg.."[INFO]ALIGN RIGHT\n"
	else
		msg = msg.."[INFO]ALIGN CENTER\n"
	end
	msg = msg.."[INFO]PROGRESS "..tostring(obj.track3/100).."\n"
	--WARN
	if lnflag then
		msg = msg.."[WARN]\"\\n\" MAY NOT BE USED\n"
	end
	if text:len()==0 then
		msg = msg.."[WARN]NO TEXT\n"
	end

	obj.load("text", msg)
	obj.draw()
	return
end

--テキスト設定
if text:len()==0 then
	return
end
obj.setfont(font, obj.track0, 0, "0xffffff")
obj.load("text", text)
local sizeX, sizeY = obj.w, obj.h
obj.setoption("drawtarget","tempbuffer",sizeX + math.abs(rubyPos[1]), sizeY + size*2 + rubySize*2 + math.abs(rubyPos[2]))
obj.draw(0,0)

--ルビ描画
if #ruby>0 then
	for i=1,#ruby do
		s, s1, s2 = string.len(text), ruby[i][3], ruby[i][4]
		rx, ry = sizeX/s * (s1+s2-1)/2 - sizeX/2 + rubyPos[1], -size/2 - rubySize + rubyPos[2]
		obj.setfont(font, rubySize, 0, "0xffffff")
		obj.load("text", ruby[i][2])
		obj.draw(rx,ry)
	end
end

obj.copybuffer("cache:text", "tmp") --objからcacheへコピー

--右側テキスト
obj.setoption("drawtarget","tempbuffer", sizeX+obj.track2*2+math.abs(rubyPos[1]), sizeY+obj.track2*2+rubySize*2+size*2+math.abs(rubyPos[2]))
obj.copybuffer("obj", "cache:text") --cacheからobjにコピー
obj.effect("グラデーション", "幅", gradWidth, "color", gradColor21, "color2", gradColor22)
obj.effect("縁取り", "サイズ", obj.track2, "color", edgeColor2, "ぼかし", edgeBokeh)
obj.effect("クリッピング", "左", obj.track3 / 100 * obj.w)
obj.draw(-obj.w/2 + sizeX/2 + obj.track2 + math.abs(rubyPos[1])/2)

--左側テキスト
obj.copybuffer("obj", "cache:text") --tempbufferからobjにコピー
obj.effect("グラデーション", "幅", gradWidth, "color", gradColor11, "color2", gradColor12)
obj.effect("縁取り", "サイズ", obj.track2, "color", edgeColor1, "ぼかし", edgeBokeh)
obj.effect("クリッピング", "右", (1 - obj.track3 / 100) * obj.w)
obj.draw(obj.w/2 - sizeX/2 - obj.track2 - math.abs(rubyPos[1])/2)


obj.load("tempbuffer")
obj.draw()

local r = math.rad(obj.rz)
if align==0 then
	obj.ox = obj.ox + (sizeX/2 * math.cos(r))
	obj.oy = obj.oy + (sizeX/2 * math.sin(r))
elseif align==2 then
	obj.ox = obj.ox - (sizeX/2 * math.cos(r))
	obj.oy = obj.oy - (sizeX/2 * math.sin(r))
end
