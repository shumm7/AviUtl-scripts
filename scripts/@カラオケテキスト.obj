--[[
カラオケテキスト v2.1 2021/06/05

＊テスト環境
 ・AviUtl 1.10
 ・exedit 0.93rc1


＊導入方法
v2.0から textmodule.dllが必要になりました！
※なくても動きますが、システム文字を一部に含む文字が入ると、正常に動かない可能性があります。
　例：ー、ゼ、ゾ など

 1.「@カラオケテキスト.obj」をscriptフォルダ or その直下のフォルダに入れる
 2.「textmodule.dll」を同じ場所に入れる
 3.カスタムオブジェクトから「カラオケテキスト」を選択


＊使い方
設定ダイアログの「テキスト」に表示したい歌詞を入力してください。
｜文章《ぶんしょう》のようにすると、ふりがなを付けることができます。
ふりがなの位置は、「ルビ調整」で相対的にずらせます。

トラックバーの「進行度」を移動させると、色が部分的に変わります。
（直線移動と中間点を使用するといいかもしれません）


＊todo
・テキストを長文にすると、ダイアログの値が消える問題
（外部ファイルに設定を移動させても良さそう）
・ルビ用の記号を半角、全角両方対応にする。
]]

@カラオケテキスト
--track0:サイズ,1,512,34,1
--track1:ルビサイズ,1,512,16,1
--track2:縁サイズ,0,100,10,1
--track3:進行度,0,100,0,0.01
--check0:デバッグ,0
--dialog:テキスト,l="これはテスト｜文章《ぶんしょう》です。";フォント,font="MS UI Gothic";縁色,edgeColor={"0xffffff", "0x000000"};縁ぼかし,edgeBokeh=10;グラデ幅,gradWidth=100;グラデ色 左,local gradColorL={"0x117ad7", "0x0f2d47"};グラデ色 右,local gradColorR={"0xffffff", "0xffffff"};左右寄せ[0-2],align=1;ルビ調整,local offset={0,0};

local line = l
local size, rubySize, rubyPos = obj.track0, obj.track1, offset
require("textmodule")

--文字列操作関数
local function find(text, pattern)
	if textmodule==nil then
		return string.find(text, pattern)
	else
		return textmodule.find(text, pattern)
	end
end
local function sub(text, s, e)
	if textmodule==nil then
		return string.sub(text, s, e)
	else
		return textmodule.sub(text, s, e)
	end
end
local function gsub(text, pattern, repl, n)
	if textmodule==nil then
		return string.gsub(text, pattern, repl, n)
	else
		return textmodule.gsub(text, pattern, repl, n)
	end
end
local function len(text)
	if textmodule==nil then
		return string.len(text)
	else
		return textmodule.len(text)
	end
end


--ルビ位置
local r = math.rad(obj.getvalue("rz"))
if rubySize>size then
	rubySize = size
end
if rubyPos==nil or #rubyPos<2 then
	rubyPos={0,0}
end

--テキスト抽出
local lnflag = false
if find(line, "\n")~=nil then
	line = gsub(line, "\n", "")
	lnflag=true
end

local exp = ""
if textmodule==nil then
	exp = "(｜.-《.-》)"
else
	exp = "(｜.*?《.*?》)"
end

local text, ruby = line, {}
if find(text, exp)~=nil then
	repeat
		s1, s2 = find(text, exp)
		temp = sub(text, s1, s2)

		local a1, a2 = find(temp, "｜.")
		local b1, b2 = find(temp, "《.")

		t = sub(temp, a2, find(temp, "《")-1)
		r = sub(temp, b2, find(temp, "》")-1)

		text = gsub(text, temp, t, 1)
		table.insert(ruby, {t, r, s1, s1 + len(t) - 1})
	until find(text, exp)==nil
end

--情報表示
if obj.check0 then
	obj.setfont(font, obj.track0, 0, "0xffffff")
	local msg = ""

	--DATA
	msg = msg.."[TEXT]"..text.."\n"
	if #ruby>0 then
		for i=1, #ruby do
			msg = msg.."[RUBY]"..ruby[i][1].."("..ruby[i][2]..") "..tostring(ruby[i][3]).."-"..tostring(ruby[i][4]).."\n"
		end
	end

	--INFO
	msg = msg.."[INFO]Ruby Offset ("..tostring(rubyPos[1])..","..tostring(rubyPos[2])..")\n"
	if align==0 then
		msg = msg.."[INFO]Align Left 0\n"
	elseif align==2 then
		msg = msg.."[INFO]Align Right 2\n"
	else
		msg = msg.."[INFO]Align Center 1\n"
	end
	msg = msg.."[INFO]Progress "..tostring(obj.track3/100).."\n"
	--WARN
	if lnflag then
		msg = msg.."[WARN]\"\\n\" may not be used\n"
	end
	if len(text)==0 then
		msg = msg.."[WARN]No Text\n"
	end
	--TEXT MODULE
	if textmodule==nil then
		msg = msg.."[WARN]textmodule.dll is missing\n"
	end

	obj.load("text", msg)
	obj.draw()
	return
end


--テキスト設定
if len(text)==0 then
	return
end
obj.setfont(font, obj.track0, 0, "0xffffff")
obj.load("text", text)
local sizeX, sizeY = obj.w, obj.h
obj.setoption("drawtarget","tempbuffer",sizeX + math.abs(rubyPos[1]), sizeY + size*2 + rubySize*2 + math.abs(rubyPos[2]))
obj.draw(0,0)

--ルビ描画
if #ruby>0 then
	for i=1,#ruby do
		s, s1, s2 = len(text), ruby[i][3], ruby[i][4]

		local rx, ry
		if textmodule==nil then
			rx, ry = sizeX/s * (s1+s2-1)/2 - sizeX/2 + rubyPos[1], -size/2 - rubySize + rubyPos[2]
		else
			rx, ry = sizeX/s * (s1+s2-1)/2 - sizeX/2 + rubyPos[1], -size/2 - rubySize + rubyPos[2]
		end
		obj.setfont(font, rubySize, 0, "0xffffff")
		obj.load("text", ruby[i][2])
		obj.draw(rx,ry)
	end
end

obj.copybuffer("cache:text", "tmp") --objからcacheへコピー

--右側テキスト
obj.setoption("drawtarget","tempbuffer", sizeX+obj.track2*2+math.abs(rubyPos[1]), sizeY+obj.track2*2+rubySize*2+size*2+math.abs(rubyPos[2]))
obj.copybuffer("obj", "cache:text") --cacheからobjにコピー
obj.effect("グラデーション", "幅", gradWidth, "color", gradColorR[1], "color2", gradColorR[2])
obj.effect("縁取り", "サイズ", obj.track2, "color", edgeColor[2], "ぼかし", edgeBokeh)
obj.effect("クリッピング", "左", obj.track3 / 100 * obj.w)
obj.draw(-obj.w/2 + sizeX/2 + obj.track2 + math.abs(rubyPos[1])/2)

--左側テキスト
obj.copybuffer("obj", "cache:text") --tempbufferからobjにコピー
obj.effect("グラデーション", "幅", gradWidth, "color", gradColorL[1], "color2", gradColorL[2])
obj.effect("縁取り", "サイズ", obj.track2, "color", edgeColor[1], "ぼかし", edgeBokeh)
obj.effect("クリッピング", "右", (1 - obj.track3 / 100) * obj.w)
obj.draw(obj.w/2 - sizeX/2 - obj.track2 - math.abs(rubyPos[1])/2)


obj.load("tempbuffer")
obj.draw()

local r = math.rad(obj.rz)
if align==0 then
	obj.ox = obj.ox + (sizeX/2 * math.cos(r))
	obj.oy = obj.oy + (sizeX/2 * math.sin(r))
elseif align==2 then
	obj.ox = obj.ox - (sizeX/2 * math.cos(r))
	obj.oy = obj.oy - (sizeX/2 * math.sin(r))
end
